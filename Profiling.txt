1) ParallelGC

- Перед запуском смотрим в Sampler на текущие показатели памяти:
  int[] = ~ 71 000 byte.
- Heap загружается примерно от 7 MB 
- Далее запускаем программу и создаем массив на 250 000 элементов.
  Теперь int[] 1 071 000+ byte.
  Прозошел резкий скачок с 7 MB до 8,5 MB, после создания массива упал до 5 MB.
- Теперь запустим сортировки и посмотрим за изменением данных

- Сортировка слиянием -

  - int[] стал 3 000 000+ byte.
  - Теперь Heap загружается в среднем с 5,5 MB до 6,5 MB, после сборщик 
    разгружает память.
  - Также видно, что параллельный сборщик не нагружает процессор, но
    при этом отработал быстро, меньше 1 секунды.

- Сортировка методом вставки -
  - Время сортировки заняло чуть больше 1 секунды.
  - int[] вырос незначительно (на 100 000 - 200 000 byte) без существенных
    накладных расходов. Никакие массивы больше не создаются.
  - Замечен скачок роста расходуемой памяти. Теперь Heap используется на
    8,5 MB. 
  - Увеличился объем собираемого мусора
  - Замечен скачок в нагрузки процессора во время сборки на 9%. Данная
    сортировка наиболее затратная.

- Сортировка пузырьком -
  - Время сортировки заняло 1 минуту 30 секунд.
  - Видим, что int[] уменьшен до 2 100 000 byte, поскольку очищены лишние клоны.
  - Нагрузка процессора на весь период сортировки (минута) выросла на 8,7%.
  - Видим периодическое уменьшение и увеличение heap в течение всего периода сортировки.